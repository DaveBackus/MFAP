\documentclass[11pt]{article}

\input{../LaTeX/preamble.tex}

\begin{document}
\parskip=\bigskipamount
\parindent=0.0in
\thispagestyle{empty}
\input{../LaTeX/header.tex}

\bigskip\bigskip
\centerline{\Large \bf Math Tools:  Recursive Methods}
\centerline{Revised: \today}

\bigskip
The concept of recursion runs throughout modern mathematics and computer science.
The same is true of economics and finance.
There's a reason the leading PhD textbook in macroeconomics
is called {\it Recursive Macroeconomic Theory\/}.
Such work in economics reflects, in large part, the adoption by economists of methods
developed elsewhere.

What follows is a short informal introduction to the idea and a start
on the kinds of applications you'll find in economics and finance.

{\it Warning:\/}
This contains a little linear algebra.
Skip it if that's not part of your skill set.


\section{Examples of recursion}

The idea is to characterize a sequence of items, indexed by an integer $n=0,1,2,\ldots$,
by a rule that connects each item to the next one.
If we label the items $x_n$, the rule might be expressed
\begin{eqnarray}
    x_{n+1} &=& g (x_n) .
    \label{eq:recurrence}
\end{eqnarray}
If we have a starting point, say $x_0$, the rule tells us how to compute
as many succeeding items as we wish.
We would say that the set $\{x_n\}$ is generated recursively
and refer to (\ref{eq:recurrence}) as the defining recurrence relation.
A ``solution'' to (\ref{eq:recurrence}) is a formula
that expresses $x_n$ as a function of $n$.

Examples:
\begin{enumerate}
\item {\it Linear difference equation.\/}
Let
\begin{eqnarray}
    x_{n+1} &=& a x_n .
    \label{eq:first-order-diff-eq-scalar}
\end{eqnarray}
This has the solution $ x_n = a^n x_0$.
It converges to zero if $ |a | < 1 $, but it's the solution either way.
%Problem:  How does it behavior if we add a constant:  eg,
%$ x_{n+1} = a x_n + b $?

\item {\it Logistic map.\/}
Let
\begin{eqnarray*}
    x_{n+1} &=& a x_n (1-x_n)
\end{eqnarray*}
with $ 0 < a \leq 4$.
If you try some experiments, you'll see that it generates wildly
different behavior depending on the value of $a$.
You might set $x_0 = 0.3$ and $a = (0.98, 1.5, 2.5, 3.25, 3.5 )$,
generate (say) 20 terms, and graph the output.
See
\href{http://en.wikipedia.org/wiki/Logistic_map}{Wikipedia}.
The point, which we won't develop further, is that even
quite simple nonlinear recurrences can generate complex behavior.

\item {\it Fibonacci numbers.\/}
The Fibonacci numbers are generated by the second order system
\begin{eqnarray*}
    f_{n+1} &=& f_n + f_{n-1}
\end{eqnarray*}
starting with $f_0 = 0$ and $f_1 = 1$.
In matrix terms, we can write this as $ x_{n+1} = A x_n $ with
\begin{eqnarray*}
        x_n &=& \left[ \begin{array}{c} f_n \\ f_{n-1} \end{array}\right],
        \;\;\;
        A \;\;=\;\; \left[ \begin{array}{cc} 1 & 1  \\ 1 & 0 \end{array}\right] .
\end{eqnarray*}
This is similar to (\ref{eq:first-order-diff-eq-scalar}), but here $x_n$ is a vector.
The matrix $A$ has eigenvalues $(\lambda_1,\lambda_2)$ satisfying
$ \lambda^2 - \lambda - 1 = 0 $.
The ``solution'' has the form $ f_n = c_1 \lambda_1^n + c_2 \lambda_2^n $ for constants
$(c_1,c_2)$ that satisfy the initial conditions.

This is a common example in computer science courses.
A recursive version of a Matlab program to compute Fibonacci numbers is
\begin{verbatim}
function answer = f(n)
if n==0
    answer = 0;
elseif n==1
    answer = 1;
else
    answer = f(n-1) + f(n-2);
end
end
\end{verbatim}
Note that the function {\tt f} refers to itself --- it's
\href{http://en.wikipedia.org/wiki/Recursion_(computer_science)}{recursive}
in the sense the word is used in computer science.
In Matlab, we would save this as a file called {\tt f.m}, then
call it by typing (say) {\tt f(8)} in the command line or as a line in another program.
(If you enter a fraction, it blows up, so a better function
would check and generate an error message,
or perhaps convert {\tt n} to an integer.)

\item {\it Mean and variance.\/}
\href{http://www.johndcook.com/standard_deviation.html}{John Cook}
describes the Welford method of computing the mean and variance recursively.
Consider a sequence of observations:  $ x_1, x_2, \ldots $.
We can compute rolling estimates of the mean and variance from
\begin{eqnarray*}
    M_n &=& M_{n-1} + (x_n - M_{n-1}) / n \\
    S_n &=& S_{n-1} + (x_n - M_{n-1})*(x_n - M_n)
\end{eqnarray*}
starting with $ M_1= x_1$ and $S_1 = 0$.
Do a few terms to assure yourself that $M_n$ is the mean of the first $n$ observations
and $S_n$ is the sum of the squared deviations from the mean.
The standard estimator of the variance $s^2$ is therefore $ S_n/(n-1)$
(although I prefer to divide by $n$, always).

\item {\it Natural numbers.\/}
The natural numbers are the set $ \mathbb{N} = \{0,1,2,\ldots \} $.
We can  define them recursively with the rules: (i)~0 is in $\mathbb{N}$
and (ii)~if $n$ is in $\mathbb{N}$ then so is $n+1$.

Which reminds me of an old George Gamov story.
In the story, the Hilbert Hotel has an infinite number of rooms numbered $1, 2, 3, \ldots $.
By law, it must save one for the King, but the innkeeper fills them all anyway.
When asked, he says:  ``No problem, I can always get an open room by
asking everyone to move over one.''
And if we move the person in room $j$ to room $2j$,
we open up an infinite (countable) number of rooms, all the odd-numbered ones.

\item {\it Combinatorics.\/}
Computer scientist
\href{http://www.math.upenn.edu/~wilf/DownldGF.html}{Herbert Wilf}
notes that many combinatoric identities satisfy recurrences.
For example, the binomial coefficients,
\begin{eqnarray*}
    f(n,k) &=&  \left( \begin{array}{c} n \\ k \end{array}\right)
            \;\;=\;\;  \frac{n!}{k!(n-k)!} ,
\end{eqnarray*}
are the solution to
\begin{eqnarray*}
    f(n,k) &=&  f(n-1,k) + f(n-1,k-1)
\end{eqnarray*}
starting with $ f(n,0) = 1$.  %?? for all n

\item {\it Functions.\/}
In economics and finance we often run across recursion with functions.
Suppose we have a sequence of functions $f_n(x)$ over some
domain $x$ that satisfy the recurrence
\begin{eqnarray*}
    f_{n+1}(x) &=& g[f_n(x)]
\end{eqnarray*}
for some $g$.
Even better, suppose the recurrence has a fixed point:
\begin{eqnarray*}
    f(x) &=& g[f(x)] .
\end{eqnarray*}
%We usually drop the $x$ and write $f = g(f) $.
Here we have an equation in which the unknown is another function $f$
rather than a number $x$.
It's similar to (\ref{eq:recurrence}), but we're dealing with a more complex object.

\end{enumerate}



\section{Recursion in asset pricing}

Similar methods show up throughout economics and finance.
The idea is to string together a series of one-period
steps --- recurrences --- similar to those we used earlier in the course.
That allows us to approach the price of (say) an $n$-period bond
with the same methods we used to price a one-period bond.

We'll do all this in Markov settings, which require some notation.
You'll recall that modern asset pricing is based on the no-arbitrage theorem:
there exists a positive pricing kernel $m$ that satisfies
$ E(mr) = 1$ for returns $r$ on all assets.
In a Markov environment, we need to keep track of the current state $z_t$
and the possible future states $z_{t+1}$.
The ingredients include:
%
\begin{itemize}
\item Probabilities.  We have a state variable $z_t$ and conditional probabilities
$ p(z_{1+1} | z_t) $.
\item Returns.  One-period returns from date $t$ to $t+1$ depend
on the state in both periods:  $r(z_,z_{t+1})$.
\item Asset pricing.  The no-arbitrage theorem becomes:  there exists a positive $m(z_t,z_{t+1})$
satisfying
\begin{eqnarray}
    E_t \big[ m(z_t,z_{t+1}) r(z_t,z_{t+1}) \big] &=& 1
    \label{eq:foc} 
\end{eqnarray}
for all returns $ r(z_t,z_{t+1} $.
Here $E_t$ is the expectation conditional on the current state $z_t$
--- the expectation computed from $p(z_{t+1} | z_t)$, in other words.
\end{itemize}

Examples:
%
\begin{enumerate}

\begin{comment}
\item {\it Discounting cash flows.\/}
We can represent equity valuation as either an infinite discounted present value or a sequence.
In the former, we might treat equity at date $t$
as a claim to the dividend stream $d_{t+1}, d_{t+2}, \ldots $
and discount them with the discount factor $\delta$:
\begin{eqnarray*}
    v_t &=& \sum_{j=1}^\infty \delta^j d_{t+j} ,
\end{eqnarray*}
In a finance course we would typically replace $\delta$ with $1/(1+i)$, but this is more compact.

Here's a recursive version where we add one dividend at a time.
Consider the sequence
\begin{eqnarray}
    v_t^{n+1} &=& \delta (d_{t+1} + v^n_{t+1} ) ,
    \label{eq:equity-deterministic}
\end{eqnarray}
starting with $v^0_t = 0$.
That gives us the sequence
\begin{eqnarray*}
    v^1_t &=& \delta (d_{t+1} + v^0_{t+1}) \;\;=\;\; \delta d_{t+1}  \\
    v^2_t &=& \delta (d_{t+1} + v^1_{t+1}) \;\;=\;\; \delta d_{t+1} + \delta^2 d_{t+2} ,
\end{eqnarray*}
and so on.
The limit of this sequence is the infinite sum.
\end{comment}


\item {\it Bond pricing.\/}
A bond of maturity $n$ is a claim to a payment of one in $n$ periods.
In a Markov setting, such bond prices are functions of the state.
The question is what the functions are.
%
We find bond prices recursively, starting with $q^0(z_t) = 1$ for
all states $z_t$ (a dollar today is worth a dollar).
Bonds of longer maturity have returns 
\begin{eqnarray*}
    r^{n+1}(z_t, z_{t+1}) &=& q^{n}(z_{t+1}) / q^{n+1}(z_{t}) .
\end{eqnarray*} 
The no-arb theorem (\ref{eq:foc}) then gives us the recursion 
\begin{eqnarray}
    q^{n+1}(z_t) &=& E_t \big[ m(z_t,z_{t+1}) q^n(z_{t+1})\big] .
    \label{eq:recursion-bond}
\end{eqnarray}
In words:  an $n+1$-period bond is a claim to an $n$-period bond in one period.

We'll spend some time with a loglinear functional form.
This takes some work, but it's worth doing because we'll be spending
some time with similar models.
Despite how it might look at first, this is a user-friendly functional form.
Suppose the pricing kernel is loglinear:
\begin{eqnarray*}
    \log m(z_t, z_{t+1} ) &=& \delta + a z_t + b z_{t+1} \\
            z_{t+1} &=& \varphi z_t + \sigma w_{t+1}
\end{eqnarray*}
with $\{ w_t \} $ a sequence of independent standard normal
random variables and $0 < \varphi < 1$.
Then bond prices are loglinear functions of the state:
\begin{eqnarray}
    \log q^n(z_t) &=& A_n + B_n z_t
    \label{eq:bond-loglin}
\end{eqnarray}
for coefficients $(A_n, B_n)$ to be determined.

The solution follows from applying (\ref{eq:recursion-bond}) to (\ref{eq:bond-loglin}).
We start with
\begin{eqnarray*}
    \log q^{n+1} ( z_t )
        &=& \log E_t \left\{
                \exp \left[ \log m(z_t,z_{t+1}) + \log q^{n}(z_{t+1}) \right]
                \right\} .
\end{eqnarray*}
We get the left side from (\ref{eq:bond-loglin}).
The right side takes some work.
The inside of the square brackets on the right can be expressed
\begin{eqnarray*}
    \log m(z_t,z_{t+1}) + \log q^{n}(z_{t+1})
            &=&  (\delta + a z_t + b z_{t+1} ) +  (A_n + B_n z_{t+1} ) \\
            &=& \delta + A_n + a z_t + (b + B_n) (\varphi z_t + \sigma w_{t+1}) .
\end{eqnarray*}
Conditional on the state $z_t$, this is normal with mean and variance
\begin{eqnarray*}
    E_t \left[ \log m(z_t,z_{t+1}) + \log q^{n}(z_{t+1}) \right]
            &=&  \delta + A_n + [a + (b + B_n) \varphi] z_t \\
    \mbox{Var}_t  \left[ \log m(z_t,z_{t+1}) + \log q^{n}(z_{t+1}) \right]
            &=& (b + B_n)^2 \sigma^2 .
\end{eqnarray*}
The usual ``mean plus variance over two'' gives us
\begin{eqnarray*}
        \log E_t \left(  m(z_t,z_{t+1}) q^{n+1}(z_{t+1}) \right)
        &=& \log E_t  \left\{
                \exp \left[ \log m(z_t,z_{t+1}) + \log q^{n+1}(z_{t+1}) \right]
                \right\} \\
        &=&  \delta + A_n + \big[ a + (b + B_n) \varphi \big] z_t  + (b+B_n)^2 \sigma^2/2 .
\end{eqnarray*}
[If this isn't clear, go through it again, it's important.]
By assumption, this equals $ A_{n+1} + B_{n+1} z_t $ for all values of $z_t$,
so we must have
\begin{eqnarray*}
    A_{n+1} &=& \delta + A_n +  (b+B_n)^2 \sigma^2/2  \\
    B_{n+1} &=& a + (b + B_n) \varphi .
\end{eqnarray*}
Evidently we've converted the recursion in $q^n(z_t)$, equation (\ref{eq:recursion-bond}),
into recursions in the coefficients $(A_n , B_n) $.
They're not pretty, but we can easily compute them.
The initial conditions $A_0 = B_0 = 0 $ correspond to $\log q^0(z_t) = \log (1) = 0$.


\begin{comment}
We studied examples earlier in which $z_t$ was one-dimensional
and the bond price was loglinear:  $ \log q^n(z_t) = A_n + B_n z_t$.
The recursions in the bond price functions in these models translate into recursions
in the coefficients $ (A_n,B_n) $.

Another class of tractable models is based on finite-state Markov chains:
$z_t$ takes on a finite number of values, say $i = 1,\ldots, I$.
Then the function $q^n(z_t)$ is a vector, say $q^n$,
with one element for every state.
By tradition, we collect the conditional (``transition'') probabilities
in a matrix $P = [p_{ij}]$,
where $p_{ij}$ is the probability that $z_{t+1} = j$ given that $z_t = i$.
Similarly, the pricing kernel is a matrix of elements $[m_{ij}]$.

In this setting, a one-period bond price in state $i$ is
\begin{eqnarray*}
    q^1_i &=& \sum_j p_{ij} m_{ij} .
\end{eqnarray*}
If we define the matrix $B = [b_{ij}] = [p_{ij} m_{ij}]$,
then in matrix terms, the one-period bond price function/vector is
\begin{eqnarray*}
    q^1 &=& B q^0 ,
\end{eqnarray*}
where $q^0$ is a vector of ones ---
the prices of 0-maturity bonds, namely one.
 Other bond prices follow recursively:
\begin{eqnarray*}
    q^{n+1} &=& B q^n .
\end{eqnarray*}
You should convince yourself that this is (\ref{eq:recursion-bond})
applied to this environment.
If we substitute, we see that $q^n = B^n q^0 $, so anything we know
about powers of positive matrices can be put to work.
\end{comment}

\item {\it Equity pricing.\/}
A dividend paying stock is a more complicated object.
In the same environment as before, let the dividend in state $z_t$ be $d(z_t)$.
The ex-dividend value of a share might be expressed recursively as
\begin{eqnarray}
    v(z_t) &=& E_t \big\{ m(z_t,z_{t+1}) [d(z_{t+1}) + v(z_{t+1})] \big\} .
    \label{eq:recursion-equity}
\end{eqnarray}
In words:  equity today is a claim to two things tomorrow,
a dividend and the same share of equity.

Note that the unknown in this equation is the function $v$.
It's also recursive:  you need to know $v$ on the right to compute $v$ on the left.
You're now as ready as you'll ever be for the recursion joke:
``To understand recursion, you need to understand recursion.''
Or Google ``recursion.'' You get back:  ``Did you mean: recursion?''

One way to think about this is as the limit of a finite horizon.
Suppose we value next period's dividend by
\begin{eqnarray*}
    v^1(z_t) &=& E_t \big\{ m(z_t,z_{t+1}) d(z_{t+1}) \big\} .
\end{eqnarray*}
The superscript 1 here means we're valuing one period of dividends.
We can value two periods of dividends recursively with
\begin{eqnarray*}
    v^2(z_t) &=& E_t \big\{ m(z_t,z_{t+1}) [d(z_{t+1}) + v^1(z_{t+1})] \big\} .
\end{eqnarray*}
In general, we can value $n+1$ periods of dividends with the recursion
\begin{eqnarray*}
    v^{n+1}(z_t) &=& E_t \big\{ m(z_t,z_{t+1}) [d(z_{t+1}) + v^n(z_{t+1})] \big\} ,
    \label{eq:recursion-equity-n}
\end{eqnarray*}
starting with $v^0(z_t) = 0$ (the value of zero dividends is zero).
As we increase $n$, we have more and more dividends.
We might imagine, if all goes well, that as $n$ gets larger and larger,
we approach (\ref{eq:recursion-equity}).

\begin{comment}
Unlike bond pricing, loglinear examples don't work.
There are some popular loglinear approximations, but that's too much work for now.
We can, however, adapt the Markov chain setup we used with bonds.
Suppose the dividend is a vector $d$, with one element for each state.
Then the pricing relation (\ref{eq:recursion-equity}) becomes
\begin{eqnarray*}
    v &=& B (d+v) .
\end{eqnarray*}
The solution is $ v = (I-B)^{-1} B d$.
Alternatively, we can substitute repeatedly to get
$ v = B d + B^2 d + B^3 d + \cdots $,
the present discounted value version of the equity price.
\end{comment}

\item {\it Perpetual American options.\/}
Consider the option to buy one share of stock next period for strike price $k$.
The value today in state $z_t$ is
\begin{eqnarray*}
    q(z_t) &=& E_t \big\{ m(z_t,z_{t+1}) [v(z_{t+1}) - k]^+ \big\} ,
\end{eqnarray*}
where $x^+ = \max \{0, x \} $.
Evidently we exercise in states where $ v(z_{t+1}) - k$ is positive
and not in other states.

A perpetual option allows us to wait.
If we don't exercise now, 
we can hold the option for another period.
Valuation has a recursive form:
\begin{eqnarray*}
    q(z_t) &=& \max \big\{ v(z_{t}) - k, E_t \big[ m(z_t,z_{t+1}) q(z_{t+1})\big] \big\} .
\end{eqnarray*}
That is:  we either exercise now and get $v(z_t)-k$ (the first branch
of the max) or continue to hold the option and get the current value of the option
next period (the second branch).

\begin{comment}
\item {\bf Utility.\/}
In dynamic settings, we often use the additive utility function,
\begin{eqnarray*}
    U(z_t) &=& E_t \sum_{j=0}^\infty \beta^j u[c(z_{t+j})] ,
\end{eqnarray*}
for some function $u$ and discount factor $ 0 < \beta < 1 $.
The familiar power utility consists of $u(c) = c^{1-\alpha}/(1-\alpha)$ with $\alpha > 0$.
Here $U_t$ means ``utility from date $t$ on.''
We can rewrite it as
\begin{eqnarray*}
    U(z_t) &=&  u[c(z_{t})] + \beta E_t [U(z_{t+1})]  .
\end{eqnarray*}
Why does this work?  Because $U(z_{t+1})$ takes care of the rest of the terms.
%We can reconstitute the previous version by repeated substitution.

As in our other examples, we can envision building this up term by term,
\begin{eqnarray*}
    U^{n+1}(z_t) &=&  u[c(z_{t})] + \beta E_t [U^n(z_{t+1})] ,
\end{eqnarray*}
starting with $U^0(z_t) = 0$.
If all goes well,
the unknown function $U(z_t)$ is the limit of the $U^n(z_t)$'s.
\end{comment}

\end{enumerate}


\section{Bottom line}

Recursive methods are at the heart of modern macroeconomics and finance.
We'll use them extensively to value bonds.


\section*{Practice problems}

\begin{enumerate}
%------------------------------------------------------------------------------
\item {\it Discounted cash flows.\/}
Our goal here is to simplify the pricing relation (\ref{eq:recursion-equity})
and derive a more conventional valuation of equity
as the expected discounted value of future dividends.
\begin{enumerate}
\item Simplify (\ref{eq:recursion-equity}) using $ m(z_t,z_{t+1}) = \delta $
and replacing dependence on the state $z_t$ with a subscript $t$ ---
that is, by replacing $v(z_t)$ with $v_t$.
\item Use this simplification to express equity's value as
\begin{eqnarray*}
    v_t &=& \sum_{j=1}^n \delta^j E_t (d_{t+j}) + \delta^n E_t (v_{t+n}) .
\end{eqnarray*}
\item What happens as $n$ gets large?
What happens to the second term on the right above?
\item What does this example leave out that's present in (\ref{eq:recursion-equity})?
\end{enumerate}

Answer.
\begin{enumerate}
\item Equation (\ref{eq:recursion-equity}) becomes
\begin{eqnarray*}
    v_t &=& \delta E_t ( d_{t+1} + v_{t+1} ) .
\end{eqnarray*}

\item This follows from repeated substitution
and the law of iterated expectations.

\item We hope that the second term goes to zero.  That leaves us with the infinite sum
\begin{eqnarray*}
    v_t &=& \sum_{j=1}^\infty \delta^j E_t (d_{t+j}) .
\end{eqnarray*}

\item If $ m(z_t,z_{t+1}) = \delta $ there are no risk premiums.
The price of equity depends only on expected future dividends.
\end{enumerate}

%------------------------------------------------------------------------------
\item {\it Consols.\/}
A consol pays a constant coupon $c$ every period --- forever.
They have been used by the British as a government financing tool since the 1700s.
How would you adapt equation (\ref{eq:recursion-equity}) to value such an instrument?

Answer.  We set $d(z_t) = c$, giving us
\begin{eqnarray*}
    v(z_t) &=& E_t \big\{ m(z_t,z_{t+1}) [c + v(z_{t+1})] \big\} .
\end{eqnarray*}
The variation in price here comes from $m$, which translates roughly
as variation in interest rates.


\begin{comment}
%------------------------------------------------------------------------------
\item {\it Consols.\/}
A consol is a perpetual bond:  it pays a coupon $c$ every period forever.
How would we value one in an exponential-affine setting?
Consider the pricing kernel
\begin{eqnarray*}
    \log m_{t+1} &=& \delta + z_t + \lambda w_{t+1} \\
    z_{t+1} &=& \varphi z_t + \sigma w_{t+1} ,
\end{eqnarray*}
where $ 0 < \varphi < 1$ and $\{ w_t\} $ is a sequence
of independent standard normal random variables.
As we've seen, this structure gives us loglinear
bond prices:
$ \log q^n(z_t) = A_n + B_n z_t $.
%
\begin{enumerate}
\item Use (\ref{eq:recursion-bond}) to find recursions for the coefficients
$(A_n,B_n)$.
\item Use your answer to find the price of a consol.
\end{enumerate}
{\it Comment about notation\/}:
$m(z_t,z_{t+1})$ is the most accurate notation,
but we (meaning economists in general) often use $m_{t,t+1}$ or $m_{t+1}$
to mean the same.
They're less accurate, but easier to write.

%\begin{comment}
\item {\it Representative agent asset pricing.\/}
(Adapted from an exercise in Ljungqvist and Sargent, {\it Recursive Macroeconomic Theory\/}.)
Consider the representative agent model with additive preferences
\begin{eqnarray*}
    U_t &=& E_t \sum_{n=0}^\infty \beta^n c_{t+n}^{1-\alpha} /(1-\alpha) .
\end{eqnarray*}
The agent's marginal rate of substitution is the pricing kernel,
 $ m_{t+1} = \beta (c_{t+1}/c_t)^{-\alpha} $.

Now suppose the growth rate $g_{t+1} = c_{t+1}/c_t$ follows
\begin{eqnarray*}
    \log g_{t+1} &=& z_t + \theta w_{t+1} \\
    z_{t+1} &=& \varphi z_t + \sigma w_{t+1}
\end{eqnarray*}
with $0 < \varphi < 1$ and $\{ w_t \}$ a sequence of iid standard normal random variables.
%
\begin{enumerate}
\item Bond prices in this economy take the form
$ \log q^n(z_t) = A_n + B_n z_t $.
Use the pricing relation $ q^{n+1}_t = E_t (m_{t+1} q^n_{t+1}) $
to compute recursions for $(A_n,B_n)$.

\item Show that future consumption has the form:
$ c_{t+1} = c_t g_{t+1}$,
$ c_{t+2} = c_t g_{t+1} g_{t+2} $,
$ c_{t+n} = c_t g_{t+1} \cdots g_{t+n} $.

\item Use this to express the $n$th term in the utility function,
namely $ E_t c_{t+n}^{1-\alpha} /(1-\alpha)$,
in terms of growth rates.
Compute these terms recursively for $n=0,1,2,\ldots $.
Hint: you might try $ \log (E_t c_{t+n}^{1-\alpha} ) = F_n + G_n c_t + H_n z_t $.

\item Express utility $U_t$ as a function of current consumption $c_t$
and the state variable $z_t$.

\item Now consider equity, a claim to future dividends,
 $ d_{t+n} = c_{t+n}^\lambda$ for $n=0,1,2,\ldots $.
Show how you can value dividends, one at a time, recursively.

\end{enumerate}

%\begin{comment}
\item Bond pricing in a Markov chain.
Coupon bonds?  Perpetuity?

\item Perpetual option. Markov chain version.

\item {\it Perpetual option: BSM version.\/}
With Black-Scholes-Merten structure, the price of a perpetual option can be solved by hand.
See the
\href{http://pages.stern.nyu.edu/~dbackus/discussions/AlvarezDixit_discussion_ms_Nov_13.pdf}{appendix}.
\end{comment}

\end{enumerate}

\input{../LaTeX/footer.tex}


\end{document}
